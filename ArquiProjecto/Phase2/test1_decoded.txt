//# 32-bit immediate shifter operand
1110 001 0000 0 0001 0000 0000 00000000

	1) Condition Code –> 1110 = ALWAYS
	2) S -> 0, doesnt modify ins. codes
	3) Opcode -> 0000 = AND
	4) Instruction Encoding – Data Processing:
		a. <opcode3>{<cond>}{S} <Rd>, <Rn>, <shifter_operand>
	5) b25 -> 1 = an immediate value
	6) Rn -> 0001 = R1
	7) Rd -> 0000 = R0
	8) rotate_imm -> 0000
	9) immed_8 -> 00000000
		shifter_operand = immed_8 rotated right (2*0) times =      	   00000
		The ARM assembly instruction is:
			AND R0, R1, #0

	EXAMPLE RUN

		if R1 = 0x00000000 then R0 = 0x00000000 since shifter_operand = 0x00000000

//# 32-bit immediate shifter operand
1110 001 1100 0 0000 0001 0000 00101000

	1) Condition Code –> 1110 = ALWAYS
	2) S -> 0, doesnt modify ins. codes
	3) Opcode -> 1100 = ORR
	4) Instruction Encoding – Data Processing:
		a. <opcode3>{<cond>}{S} <Rd>, <Rn>, <shifter_operand>
	5) b25 -> 1 = an immediate value
	6) Rn -> 0000 = R0
	7) Rd -> 0001 = R1
	8) rotate_imm -> 0000
	9) immed_8 -> 00101000
		shifter_operand = 00101000 rotated right (2*0000) times =  0x00000028
		The ARM assembly instruction is:
			ORR R1, R0, 0x00000028

	EXAMPLE RUN

		if R0 = 0x00000000 then R1 = 0x00000028 since shifter_operand = 0x00000028

//# [<Rn>, +/-<Rm>] Load n Store Register offset
1110 01 1 1 1 1 0 1 0001 0010 00000000 0000

	1) Condition Code –> 1110 = ALWAYS
	2) b27 – b25 -> 011
		Load/store register offset
	4) P = 1 = mem address generated by applying the offset 	to the base register value
	5) U = 1 = offset is added to the base
	6) B = 1 = unsigned byte
	7) W = 0 = base register is not updated
	8) L = 1 = Load = LDR
	9) Rn = 0001 = R1
	10) Rd = 0010 = R2
	11) immediate = 000000000000 = 0x00000000
		The specific load/store register offset is register offset since bit 21 is 0
	12) Rm = 0000 = R0
		The ARM assembly instruction is:
		LDRB R2, [R1, R0]

	EXAMPLE RUN

		if R0 = 0x00000000, R1 = 0x00000028 then R2 = least significant byte of address = 0x00000028

//# [<Rn>, #+/-<offset_12>] Immediate offset
1110 01 0 1 1 1 0 1 0001 0011 000000000010

	1) Condition Code –> 1110 = ALWAYS
	2) b27 – b25 -> 010
		Load/store immediate offset
	4) P = 1 = mem address generated by applying the offset 	to the base register value
	5) U = 1 = offset is added to the base
	6) B = 1 = unsigned byte
	7) W = 0 = base register is not updated
	8) L = 1 = Load = LDR
	9) Rn = 0001 = R1
	10) Rd = 0011 = R3
	11) offset_12 = 000000000010 = 0x00000002
		The specific load/store immediate offset is immediate offset since bit 21 is 0

		The ARM assembly instruction is:
		LDRB R3, [R1, #2]

	EXAMPLE RUN

		if R1 = 0x00000028, then R3 = LSB in address 0x0000002A

//# Shift by immediate shifter operand
1110 00 0 0100 0 0000 0101 00000 00 0 0000

	1) Condition Code –> 1110 = ALWAYS
	2) S -> 0, doesnt modify ins. codes
	3) Opcode -> 0100 = ADD
	4) Instruction Encoding – Data Processing:
		a. <opcode3>{<cond>}{S} <Rd>, <Rn>, <shifter_operand>
	5) b25 -> 0 = not an immediate value
	6) Rn -> 0000 = R0
	7) Rd -> 0101 = R5
	8) Rm -> 0000 = R0
	9) shift_imm -> 00000
	10) shift -> 00 LSL
		shifter_operand = Rm content logically shifted left 00000 times = Rm
		The ARM assembly instruction is:
			ADD R5, R0, R0, LSL #0

	EXAMPLE RUN

		if R0 = 0x00000000 then R5 = 0x00000000 since R5 = R0 + R0

//# Shift by immediate shifter operand
1110 00 0 0100 0 0010 0101 00000 00 0 0101

	1) Condition Code –> 1110 = ALWAYS
	2) S -> 0, doesnt modify ins. codes
	3) Opcode -> 0100 = ADD
	4) Instruction Encoding – Data Processing:
		a. <opcode3>{<cond>}{S} <Rd>, <Rn>, <shifter_operand>
	5) b25 -> 0 = not an immediate value
	6) Rn -> 0010 = R2
	7) Rd -> 0101 = R5
	8) Rm -> 0101 = R5
	9) shift_imm -> 00000
	10) shift -> 00 LSL
		shifter_operand = Rm content logically shifted left 00000 times = Rm
		The ARM assembly instruction is:
			ADD R5, R2, R5, LSL #0

	EXAMPLE RUN

		if R5 = 0x00000000 and R2 = LSB in address 0x00000028 then R5 = LSB in address 0x00000028 since R5 = R2 + R5

//# 32-bit immediate shifter operand
1110 001 0010 1 0011 0011 0000 00000001

	1) Condition Code –> 1110 = ALWAYS
	2) S -> 1, modifies ins. codes
	3) Opcode -> 0010 = SUB
	4) Instruction Encoding – Data Processing:
		a. <opcode3>{<cond>}{S} <Rd>, <Rn>, <shifter_operand>
	5) b25 -> 1 = an immediate value
	6) Rn -> 0011 = R3
	7) Rd -> 0011 = R3
	8) rotate_imm -> 0000
	9) immed_8 -> 00000001
		shifter_operand = 00000001 rotated right (2*0000) times =  0x00000001
		The ARM assembly instruction is:
			SUBS R3, R3, 0x00000001

	EXAMPLE RUN

		if R3 = LSB in address 0x0000002A then R3 = LSB in address 0x0000002A - 1

// Branch
0001 101 0 111111111111111111111101

	1) Condition Code –> 0001 = NE
	2) L -> 0, Branch
	3) signed_immed_24 = 111111111111111111111101
		signed extended to 30 bits and shifted left two bits
			11111111111111111111111111110100
	4) The ARM assembly instruction is:
			BNE label; branch to label if zero flag is not set

	EXAMPLE RUN

		if PC = address of this inst. plus 8 bytes, the PC = PC + 0xFFFFFFF4

// Immediate Offset
1110 01 0 1 1 1 0 0 0001 0101 000000000011

	1) Condition Code –> 1110 = ALWAYS
	2) b27 – b25 -> 010
		Load/store immediate offset
	4) P = 1 = mem address generated by applying the offset 	to the base register value
	5) U = 1 = offset is added to the base
	6) B = 1 = unsigned byte
	7) W = 0 = base register is not updated
	8) L = 0 = Store = STR
	9) Rn = 0001 = R1
	10) Rd = 0101 = R5
	11) offset_12 = 000000000011 = 0x00000003
		The specific load/store immediate offset is immediate offset since bit 21 is 0

		The ARM assembly instruction is:
		STRB R5, [R1, #3]

	EXAMPLE RUN

		if R1 = 0x00000028, then R5 = LSB in address 0x0000002B

// Branch
1110 101 0 000000000000000000000001

	1) Condition Code –> 1110 = AL
	2) L -> 0, Branch
	3) signed_immed_24 = 000000000000000000000001
		signed extended to 30 bits and shifted left two bits
			00000000000000000000000000000100
	4) The ARM assembly instruction is:
			B label; branch to label

	EXAMPLE RUN

		PC = PC + 0x00000004

// Branch
0000 101 1 000001010000011100000100

	1) Condition Code –> 0000 = EQ
	2) L -> 1, Branch with Link
	3) signed_immed_24 = 000001010000011100000100
		signed extended to 30 bits and shifted left two bits
			0000 0000 0001 0100 0001 1100 0001 0000
	4) The ARM assembly instruction is:
			BL func; branch to label if zero flag is set

	EXAMPLE RUN

		PC = PC plus 8 bytes and PC = PC + 0x00141C10

// Branch
1110 101 0 111111111111111111111111

	1) Condition Code –> 0000 = EQ
	2) L -> 0, Branch
	3) signed_immed_24 = 111111111111111111111111
		signed extended to 30 bits and shifted left two bits
			1111 1111 1111 1111 1111 1111 1111 1100
	4) The ARM assembly instruction is:
			B label; branch to label if zero flag is set

	EXAMPLE RUN

		PC = PC + 0xFFFFFFFC